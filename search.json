[{"title":"Keep your Python environment clean with virtualenv","url":"/2021/03/23/separate-Python-envs/","content":"\nAs Cloud Engineer I am working with Python and from time to time scripts/apps can require different Python versions or use many different dependencies. This can lead to some mess if I would like to do all those Python things on my OS. But have no fear - this is where virtualenv comes into play. Thanks to that neat tool we can create isolated Python environments for our projects/applications without messing with each project environment. Installation and usage are VERY simple so let's go through it, shall we?\n\n# Installation\nThis couldnt be easier:\n```pip install virtualenv```\n\n# Creating virtualenv\nNow we need directory for our virtualenvs, it can be anywhere but i prefer to have one dir with all my virtual environments so in my example:  \n`mkdir venvs`  \n`cd venvs`   \nNext create environment  \n`virtualenv NAME_OF_ENVIRONMENT`\n\n# Usage\nnow everything we need is just to activate our virtual environment by\n`source NAME_OF_ENVIRONMENT/bin/activate`  \ni would also recommend to add it as alias in your .zshrc for example:\n`alias py3=\"source ~/venvs/Python3/bin/activate\"`\nso next time you activate it just by calling `py3` for example.     \nIf you activated virtualenv you should see in your terminal prompt name of that venv and that mean you are good to go!   \nNow any package installed with pip (`pip install PACKAGE_NAME`) is hold in that virtual environment \nwithout messing anything directly on you OS.\n\nLast thing that will be needed is deactivating your virtualenv which couldn't be simpler:  \n`deactivate` - after writing this in terminal you will exit from virtual environment.\n\nThat's basically all, i hope this short \"how to\" was useful and make your work easier.  \nSee you next time!\n\n\n\n","tags":["python","virtualenv","virtual environments","dev","devops"],"categories":["Python"]},{"title":"PowerCLI that can save you a lot of time","url":"/2021/03/19/PowerCLI-that-can-save/","content":"\n# PowerCLI one-liners\nHere are some on-liners which back in the days when i was working with VMware i always had in my pocket as they help to save a lot of time by finding something or automate some process.\n\n\nGet VM from host cluster on specified datastore\n```\nGet-Cluster \"CLUSTER_NAME\" | Get-VM |?{($_.extensiondata.config.datastoreurl|?{$_.name -eq \"ESXI_NAME\"})}\n```\n\nList snapshots older than 3 days\n```\nGet-VM | Get=Snapshot | Where {$_.Created -Lt (Get-Date).AddDays(-3)} | Select-Object VM, Name, Created\n```\n\n\nDelete snapshots older than 3 days\n```\nGet-VM | Get=Snapshot | Where {$_.Created -Lt (Get-Date).AddDays(-3)} | Remove-Snapshot -Confirm:$false\n```\n\n\nFree space on datastores connected to the host\n```\nGet-Datastore -VMHost ESXI_NAME| select-object name, CapacityGB, @{Label=\"FreespaceGB\";E={\"{0:n2}\" -f($_.FreespaceGB)}} | sort name\nor\nget-datastore | select-object name, CapacityGB, @{Label=\"FreespaceGB\";E={\"{0:n2}\" -f($_.FreespaceGB)}}\n\n```\n\n\nDatastore name & naa\n```\n$esxName = \"ESXI_NAME\"\nConnect-VIServer vcenter_server_name\nGet-VMHost -Name $esxName | Get-Datastore |\nWhere-Object {$_.ExtensionData.Info.GetType().Name -eq \"VmfsDatastoreInfo\"} |\nForEach-Object {\nif ($_)\n{\n$Datastore = $_\n$Datastore.ExtensionData.Info.Vmfs.Extent |\nSelect-Object -Property @{Name=\"Name\";Expression={$Datastore.Name}},\nDiskName\n}\n}\n```\n\nDatastore NAA\n```\nget-datastore | ? { $_.Name -like \"DATASTORE_NAME\" } | Select Name, @{N=\"Naa\";E={$_.extensiondata.info.vmfs.extent.diskname}} | Sort Name\n```\n\n\nESXi WWN\n```\nGet-Cluster \"CLUSTER_NAME\" | Get-VMhost | Get-VMHostHBA -Type FibreChannel | where {$_.Status -eq \"online\"} | Select @{N=\"Cluster\";E={$cluster}},VMHost,Device,@{N=\"WWN\";E={\"{0:X}\"-f$_.PortWorldWideName}} | Sort VMhost,Device\n```\n\n\nHost utilization\n```\nGet-VMHost | Sort-Object -Property Name |\nFormat-Table Name,State,CpuTotalMhz,CpuUsageMhz, MemoryTotalMB, MemoryUsageMB,\n  @{N=\"Status\";E={$_.ExtensionData.Summary.OverallStatus}},\n  @{N=\"CPU%\";E={[Math]::Round(100*$_.ExtensionData.Summary.QuickStats.OverallCpuUsage/($_.ExtensionData.Summary.Hardware.CpuMhz*$_.ExtensionData.Summary.Hardware.NumCpuCores),0)}},\n  @{N=\"Mem%\";E={[Math]::Round(100*$_.ExtensionData.Summary.QuickStats.OverallMemoryUsage*1MB/$_.ExtensionData.Summary.Hardware.MemorySize,0)}} | Export-csv c:\\temp\\myreportutilization.csv\n```\n\nStart VM\n```\n$vms = get-vm ; foreach ($vm in $vms){Start-VM -VM $vm.name}\n```\n\n\nShutdown-guest-OS\n```\n$vms = get-vm ; foreach ($vm in $vms){Shutdown-VMGuest -VM $vm.name -Confirm:$false}\n```\n\n\nStop VM - shutdown VM /!\\ No guest OS shutdown /!\\\n```\n$vms = get-vm ; foreach ($vm in $vms){Stop-VM -VM $vm.name -Confirm:$false}\n```\n\n\nShutdown-guest-OS per datastore\n```\n$vms = get-vm -datastore [datastore] ; foreach ($vm in $vms){Shutdown-VMGuest -VM $vm.name -Confirm:$false}\n```\n\n\nRemove VM (delete Permanently)\n```\n$vms = get-vm ; foreach ($vm in $vms){Remove-VM -VM $vm.name -DeletePermanently -Confirm:$false}\n```\n\n\nUnmount virtual CD-ROM\n```\nGet-VM <filters> | Get-CDDrive | Set-CDDrive -NoMedia -Confirm:$false\n```\n\n\nRescan SAN (all)\n```\nGet-VMHost | Get-VMHostStorage -RescanAllHba\nGet-VMHost | Get-VMHostStorage -RescanVMFS\n```\n\nRescan HBA and NFS in cluster\n```\nGet-Cluster -Name “CLUSTER_NAME” | Get-VMHost | Get-VMHostStorage -RescanAllHba\n```\n\nCheck SAN Policy\n```\n$hs = get-vmhost ; foreach ($h in $hs){get-scsilun -vmhost $h -luntype disk}\n```\n\n\nSet SAN policy to Round Robin\n```\n$hs = get-vmhost ; foreach ($h in $hs){get-scsilun -vmhost $h -luntype disk | set-scsilun -multipathpolicy \"RoundRobin\"}\n\nor only for LUN path with fixed policy\n\n$hs = get-vmhost ; foreach ($h in $hs){get-scsilun -vmhost $h -luntype disk | where {$_.MultipathPolicy -eq \"Fixed\"} | set-scsilun -multipathpolicy \"RoundRobin\"}\n```\n\nVMotion Bulk !\n```\nGet-VM -Location (Get-VMHost ‘<filters>’) | Move-VM -Destination (GetVM-Host ‘<filters>’)\n```\n\n\nVmotion Bulk ! (sequential)\n```\n$vms = get-vm <filters> -Location <filters> ; foreach($vm in $vms){ $task = move-vm $vm -Destination <filters> -RunAsync ; Wait-Task -Task $task }\n```\n\n\nVMotion Bulk ! With selected vm\n```\n$vms = get-vm -Location <filters> | sort MemoryGB | Select-Object -last 30 ; foreach($vm in $vms){ $task = move-vm $vm -Destination <filters> -RunAsync ; Wait-Task -Task $task }\n```\n\n\nMove to folder\n```\nget-vm <filters> | move-vm -destination <filters>\n```\n\n\nGet VM Size (GB)\n```\nget-vm | get-view | Select @{N=\"Name\";E={$_.name}}, @{N=\"Size(GB)\";E={[math]::Round((($_.Storage.PerDatastoreUsage.Committed)+($_.Storage.PerDatastoreUsage.Uncommitted))/ 1GB)}}, @{N=\"Used(GB)\";E={[math]::Round(($_.Storage.PerDatastoreUsage.Committed)/ 1GB)}}\n```\n\n\nGet VM need disk consolidate\n```\nGet-VM | Where-Object {$_.Extensiondata.Runtime.ConsolidationNeeded}\n```\n\n\nConsolidate snapshot\n```\nGet-VM | Where-Object {$_.Extensiondata.Runtime.ConsolidationNeeded} | ForEach-Object {$_.ExtensionData.ConsolidateVMDisks()}\n```\n\nSearch VM on Datastore\n```\n\tdir -Recurse -Path vmstores:\\ -Include *.vmx | select Name,DatastoreFullPath\n```\n\n\nParse All pNics with model, drivers, drivers, version\n```\n$allvmnics = @() ; $vmnics = @() ; $vmhosts = get-vmhost | Where-Object {$_.ConnectionState -eq \"Connected\"} | sort name ; foreach ($vmhost in $vmhosts) { $vmnics += get-vmhostnetworkadapter -Physical -vmhost $vmhost | Select @{N=\"HostName\"; E={$vmhost}}, DeviceName } ; foreach ($vmnic in $vmnics) { $esxcli = get-esxcli -vmhost $vmnic.Hostname ; $allvmnics += $vmnic | select @{N=\"Hostname\" ; E={$vmnic.HostName}}, @{N=\"DeviceName\" ; E={$vmnic.DeviceName}}, @{N=\"NicModel\" ; E={$nicmodel = $esxcli.network.nic.list() | where-object {$vmnic.DeviceName -eq $_.name}; $nicmodel.Description}} , @{N=\"Drivers\" ; E={$esxcli.network.nic.get($vmnic.DeviceName).DriverInfo.Driver}}, @{N=\"DriverVersion\";E={$esxcli.network.nic.get($vmnic.DeviceName).DriverInfo.Version}}} ; $allvmnics | Sort-Object Hostname, DeviceName | Format-Table -auto\n```\n\n\nParse network info (CDP)\n```\n$cdpinfo = @() ; Get-VMHost | Where-Object {$_.ConnectionState -eq \"Connected\"} | sort Name | %{Get-View $_.ID} | %{$esxname = $_.Name; Get-View $_.ConfigManager.NetworkSystem} | %{ foreach($physnic in $_.NetworkInfo.Pnic){ $pnicInfo = $_.QueryNetworkHint($physnic.Device); foreach($hint in $pnicInfo){ if( $hint.ConnectedSwitchPort ) { $cdpinfo = $hint.ConnectedSwitchPort | select SystemName, PortId, Location } else { $cdpinfo = \"No CDP information available.\" } ; write-host $esxname $physnic.Device $cdpinfo.SystemName $cdpinfo.PortId $cdpinfo.Location } } }\n```\n\n\nGet vcenter, cluster, esx\n```\nget-vmhost | Select @{N=\"vCenter\";E={$_.ExtensionData.CLient.ServiceUrl.Split('/')[2]}}, @{N=\"Cluster\";E={get-cluster -vmhost $_.Name}}, Name\n```\n\n\nGet dVswitch info\n\n\tget-vmhost | sort Name | %{ $esxname = $_.Name ; get-vdswitch -vmhost $esxname} | %{ $dvswitch = $_.Name ; Get-VDport -VDSwitch $dvswitch -uplink } | Get-VDUplinkLacpPolicy | Select @{N=\"Hostname\";E={$esxname}}, @{N=\"DVswitch\";E={$dvswitch}}, @{N=\"LACPEnabled\";E={$_.Enabled}}, @{N=\"LACPMode\";E={$_.Mode}} | group-object DVswitch\n\n\nFind the biggest VM on the fullest DS\n```\nget-vm -datastore (get-datastore <filter>) | get-view | Select @{N=\"Name\";E={$_.name}}, @{N=\"Size(GB)\";E={[math]::Round((($_.Storage.PerDatastoreUsage.Committed)+($_.Storage.PerDatastoreUsage.Uncommitted))/ 1GB)}}, @{N=\"Used(GB)\";E={[math]::Round(($_.Storage.PerDatastoreUsage.Committed)/ 1GB)}} | Sort \"Used(GB)\" | select-object -last 1\n```\n\n\nGet NTP configuration by host (updated)\n\n\tGet-VMHost | Where-Object {$_.ConnectionState -ne \"Disconnected\"} | Sort Name | Select-Object @{N=\"vCenter\";E={$_.ExtensionData.CLient.ServiceUrl.Split('/')[2]}}, Name, @{Name=\"NTPServer\";Expression={$_ | Get-VMHostNtpServer}}, @{Name=\"NTPRunning\";Expression={($_ | Get-VMHostService | Where-Object {$_.key -eq \"ntpd\"}).Running}} | ft -auto\n\n\nGet DvPortGroup per VM for a datastore\n\n\t$vms = get-vm -datastore DATASTORE_NAME ; foreach ($vm in $vms){$DvPortGroup = Get-VirtualPortGroup -vm $vm.Name ; $vm | Select @{N=\"Name\";E={$_.name}}, @{N=\"DvPortGroup\";E={$DvPortGroup.Name}}} | ft -autosize\n\n\nAdd NFS datastore on All Hosts on a Cluster\n```\nget-cluster <filter> | get-vmhost | New-Datastore -Nfs -Name <name> -Path <path> -NfsHost <nfsname|@ip>\n```\n\n\nExport all portgroup\n```\nGet-VDPortgroup | Select Name, VirtualSwitch, Datacenter, VlanConfiguration | Export-Csv \"file.csv\"\n```\n\n\nGet-VM PowerOff with Notes\n```\nGet-vm | where { $_.PowerState -eq \"PoweredOff\"} | Select @{N=\"Name\";E={$_.Name}},@{N=\"PowerState\";E={$_.PowerState}},@{N=\"Note\";E={Get-VM $_ | Select-Object -ExpandProperty Notes}}\n```\n\t\n\t\nPowerOff VM from list\n```\nforeach($vmlist in (Get-Content -Path C:\\TEMP\\vmlist.txt)){ $vm = Get-VM -Name $vmlist Shutdown-VMGuest -VM $vm -Confirm:$false}\n```\n\n\nGet VM with technical stuff\n```\nGet-vm | Select @{N=\"Name\";E={$_.Name}},@{N=\"PowerState\";E={$_.PowerState}}, @{N=\"vCenter\";E={(get-vmhost -VM $_.Name).ExtensionData.CLient.ServiceUrl.Split('/')[2]}}, @{N=\"Cluster\";E={(Get-Cluster -vmhost (get-vmhost -VM $_.Name).Name).Name}}, @{N=\"VMhost\";E={(get-vmhost -VM $_.Name).Name}} | ft -autosize\n```\n\n\nGet-datastore Naa\n```\nget-datastore | ? { $_.Name -like <filter> } | Select Name, @{N=\"Naa\";E={$_.extensiondata.info.vmfs.extent.diskname}}\n```\n\n\nGet WWN with HBA Status for all Hosts\n```\nGet-VMHost | Get-VMHostHBA -Type Fibrechannel | Select @{N=\"vCenter\";E={(get-vmhost $_.VMHost).ExtensionData.CLient.ServiceUrl.Split('/')[2]}}, @{N=\"Cluster\";E={(get-vmhost $_.VMHost).Parent}}, VMHost, Device, Status, @{N=\"WWN\";E={\"{0:X}\" -f $_.PortWorldWideName}} | Sort vCenter, Cluster, VMHost, Device | ft -auto\n```\n\n\nGet-VM by selected guest OS\n\n\tGet-VM | Where {$_.PowerState -eq \"PoweredOn\" -and $_.Guest.OSFullName -like \"<filter>\"} | select @{N=\"Name\";E={$_.Name}}, @{N=\"Guest-OS\";E={$_.Guest.OSFullName}}\n\n\nGet-VM by name / OS\n\n\tget-vm | Select @{N=\"Name\";E={$_.name}}, @{N=\"GuestOS\";E={$_.Guest.OSFullName}}\n\n\nGet VM Stats (24h)\n\n\tget-vm | Where {$_.PowerState -eq \"PoweredOn\"} | Sort Name | Select Name, Host, NumCpu, MemoryMB, @{N=\"Cpu.UsageMhz.Average\";E={[Math]::Round((($_ |Get-Stat -Stat cpu.usagemhz.average -Start (Get-Date).AddHours(-24)-IntervalMins 5 -MaxSamples (12) |Measure-Object Value -Average).Average),2)}}, @{N=\"Mem.Usage.Average\";E={[Math]::Round((($_ |Get-Stat -Stat mem.usage.average -Start (Get-Date).AddHours(-24)-IntervalMins 5 -MaxSamples (12) |Measure-Object Value -Average).Average),2)}} | Format-Table -auto\n\n\nGet VM Stats (30 Days)\n\n\tGet-VM | Where {$_.PowerState -eq \"PoweredOn\"} | Select Name, Host, NumCpu, MemoryMB, @{N=\"CPU(100)\" ; E={[Math]::Round((($_ | Get-Stat -Stat cpu.usage.average -Start (Get-Date).AddHours(-720) -IntervalMins 5 -MaxSamples (8640) | Measure-Object Value -Average).Average),2)}}, @{N=\"Memory(100)\" ; E={[Math]::Round((($_ | Get-Stat -Stat mem.usage.average -Start (Get-Date).AddHours(-720) -IntervalMins 5 -MaxSamples (8640) | Measure-Object Value -Average).Average),2)}} , @{N=\"Network(KBps)\" ; E={[Math]::Round((($_ | Get-Stat -Stat net.usage.average -Start (Get-Date).AddHours(-720) -IntervalMins 5 -MaxSamples (8640) | Measure-Object Value -Average).Average),2)}} | Format-Table -auto\n\n\nStar SSH daemon on all host in a cluster\n```\nGet-Cluster | Get-VMHost | ForEach {Start-VMHostService -HostService ($_ | Get-VMHostService | Where {$_.Key -eq “TSM-SSH”})}\n```\n\n\nStorage information per VM\n\n\tget-cluster | get-vmhost | get-vm | Get-HardDisk | Select @{N=\"Host\";E={$(get-vm $_.Parent).host}}, Parent, CapacityGB, @{N=\"RealUsageGB\";E={[math]::Round(((($_.Parent | get-view).Storage.PerDatastoreUsage.Committed)+(($vm | get-view).Storage.PerDatastoreUsage.Uncommitted))/ 1GB)}}, StorageFormat, Filename\n\n\nGet Uptime for each vmhost\n```\nGet-VMHost | Get-View | select Name, @{N=\"Uptime\"; E={(Get-Date) - $_.Summary.Runtime.BootTime}} | Sort Name\n```\n\n\nSearch iso image on all datastores\n```\ndir -Recurse -Path vmstores:\\ -Include *.iso | select Name,DatastoreFullPath\n```\n\n\nManage CD image\n```\nNew-CDDrive -VM VM -ISOPath \"DatastoreFullPath\"\n\nGet-VM (filter vm) | Get-CDDrive | Where { $_.IsoPath } | Select Parent, IsoPath, ConnectionState\n\nget-vm (filter vm) | Get-CDDrive | Where { $_.IsoPath } | Set-CDDrive -connected:$true -Confirm:$false\n\nNew-CDDrive -VM VM -ISOPath \"[sof-20666-esx:storage1] ISO\\testISO.iso\"\n```\n\nGet VM @MAC\n```\nget-vm | Select @{N=\"vCenter\";E={(get-vmhost -VM $_.Name).ExtensionData.CLient.ServiceUrl.Split('/')[2]}}, @{N=\"Cluster\";E={(Get-Cluster -vmhost $_.VMhost).Name}}, VMhost, Name, @{N=\"PowerState\";E={$_.PowerState}}, @{N=\"MAC\";E={($_ | Get-NetworkAdapter).MacAddress}}, @{N=\"MACType\";E={($_ | Get-NetworkAdapter).ExtensionData.AddressType}}\n```\n\n\nGet VM with Ping status and host\n```\nGet-VM | Select Name, PowerState, @{N=\"Ping\";E={if($_.PowerState -eq \"PoweredOn\" -and (Test-Connection -ComputerName $_.Name)){\"Online\"}else{\"Offline\"}}}, VMHost | ft -auto\n```\n\n\nCheck hardware acceleration\n```\nget-vmhost | where-object {$_.ConnectionState -eq \"Connected\"} | Sort Name | Select Name, @{N=\"Move\";E={ ($_ | Get-AdvancedSetting -name DataMover.HardwareAcceleratedMove).Value }}, @{N=\"Init\";E={ ($_ | Get-AdvancedSetting -name DataMover.HardwareAcceleratedInit).Value }}, @{N=\"VMFS3Lock\";E={ ($_ | Get-AdvancedSetting -name VMFS3.HardwareAcceleratedLocking).Value }}, @{N=\"VMFS3Delete\";E={ ($_ | Get-AdvancedSetting -name VMFS3.EnableBlockDelete).Value }}, @{N=\"TransferSize\";E={ ($_ | Get-AdvancedSetting -name DataMover.MaxHWTransferSize).Value }} | ft -auto\n```\n\n\nGet-VM with multi lines Notes\n```\nGet-VM | Select @{N=\"Name\";E={$_.Name}}, @{N=\"Notes\";E={$_.Notes -replace(\"`r`n\", \" \")}}\n\nor\n\nGet-VM | Select @{N=\"Name\";E={$_.Name}}, @{N=\"Notes\";E={$_.Notes -replace(\"`n\", \" \")}}\n```\n\nCluster + host + datastore Naa + MultipathPolicy + DS size\n```\nGet-Cluster | sort Name | get-vmhost | where {$_.ConnectionState -eq \"Connected\"} | sort name | get-scsilun -LunType disk | Select @{N=\"Cluster\";E={(get-vmhost $_.VMHost).Parent}}, VMHost, CanonicalName, MultipathPolicy, CapacityGB | ft -auto\n```\n\n","tags":["vmware","powercli","cmd","scripting","automation"]},{"title":"Start blog with Hexo","url":"/2020/11/05/Start-blog-with-Hexo/","content":"Beginning...\n===============\n\nI finally decided to start blog to save memories from my IT journey. Don't get me wrong \ni tried to start own blog many times(too many :-D) but this time I'm really doing this!\nAfter some research i decided to go with Hexo because of Node.js and simplicity.\n<br/>\nI will shortly guide you how to setup Hexo on Github. \nInstruction of pages repository creation can be found at [GitHub](https://pages.github.com/) it is \neasy and well explained so o won't go through it here.\nLet's focus on Hexo now:\n<br/>\n\n## Install npm\nFirst of all you will need to install npm if you dont have it already.(npm is distributed with Node.js)\n\n*  **Mac**\n <br/>`curl`\n{% codeblock %}\ncurl \"https://nodejs.org/dist/latest/node-${VERSION:-$(wget -qO- https://nodejs.org/dist/latest/ | sed -nE 's|.*>node-(.*)\\.pkg</a>.*|\\1|p')}.pkg\" > \"$HOME/Downloads/node-latest.pkg\" && sudo installer -store -pkg \"$HOME/Downloads/node-latest.pkg\" -target \"/\"\n{% endcodeblock %}\n<br/>`Homebrew`\n{% codeblock %}brew install node{% endcodeblock %}\n<br/>`Mac pkg`\nJust download and install package from [nodejs.org](https://nodejs.org/en/download/current)\n<br/>\n\n*  **Windows**\n<br/>`Scoop`\n{% codeblock %}scoop install nodejs{% endcodeblock %}\n<br/>`Chocolatey`\n{% codeblock %}choco install nodejs{% endcodeblock %}\n<br/>`msi installer`\nDownload and install Windows Installer (.msi) from [nodejs.org](https://nodejs.org/en/download/current)\n<br/>\n\n## Install Hexo\nAfter we got Node.js the installation of Hexo is straightforward:\n{% codeblock %}npm install hexo-cli -g{% endcodeblock %}\n\n## Setup\nNow let's create our project with Hexo\n{% codeblock %}hexo init PROJECT_NAME{% endcodeblock %}\nThis will create folder `PROJECT_NAME` and clone Hexo files from GitHub repository\nto our local system.\nnext:\n{% codeblock %}cd PROJECT_NAME & npm install{% endcodeblock %}\nAt this point all necessary files should be in place. To confirm\nwe can run:\n{% codeblock %}hexo server{% endcodeblock %}\nThis will start Hexo local server and allow us to view our blog in web browser\nunder address mentioned in command output (`http://localhost:4000`).\nAnd here it is\n![Imgur](https://i.imgur.com/pZRwOa5.png)\n<br/>\n\nOk! but this is only \"Hello World\" template so press CTRL+C and let's start configuration.\n<br/>\n* **Theme**\nYou can create own theme or if you like me and can't wait to start blogging use one from already existing. Lot's of themes can be found on Hexo [website](https://hexo.io/themes/). Installation of themes is very easy: \n\t+ Pick theme \n\t+ clone it to theme folder \n\t+ edit _config.yml with {% codeblock %}theme: THEME_NAME{% endcodeblock %}\n\nThemes have they own _config.yml in which we can edit menu items, title etc. I'm pretty sure anybody can hadle configuration and customization of theme.\n<br/>\n* **_config.yml**\nFor overal explenation please visit https://hexo.io/docs/configuration.html.\nFrom my side i would sugest to install [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git).\n{% codeblock %}npm install hexo-deployer-git --save{% endcodeblock %}\nThen in main `_config.yml` add:\n{% codeblock %}\ndeploy:\n  type: git\n  repository:\n    github: <repository url>\n{% endcodeblock %}\nfrom now on every time when you will use {% codeblock %}hexo deploy{% endcodeblock %} it will push your website\nstraight to Github! Isn't that awesome ?\nThere is one more plugin that i highly recommend to install it's called [hexo-backup-git](https://github.com/coneycode/hexo-git-backup)\nThis will backup your whole hexo configuration so if you get into some trouble with some config or just want to get access to it from other computer\nit is the best and quickest solution in my opinion.\nInstallation is easy as always:\n{% codeblock %}npm install hexo-git-backup --save{% endcodeblock %}\nas always add proper configuration in `_config.yml`\n{% codeblock %}\nbackup:\n    type: git\n    repository:\n       github: <repository url>\n{% endcodeblock %}\nusage of this plugin is same as in previous, to backup configuration type in terminal\n{% codeblock %}hexo backup{% endcodeblock %} or {% codeblock %}hexo b{% endcodeblock %}\n\n## Start blogging\nAfter configuring Hexo, blogging is just a breeze:\n* create new post md file\n{% codeblock %}hexo new POST_FILE_NAME{% endcodeblock %}\n* create new page md file\n{% codeblock %}hexo new page PAGE_FILE{% endcodeblock %}\n* Cleans the cache file (db.json) and generated files (public).\n{% codeblock %}hexo clean{% endcodeblock %}\n* start hexo server to see changes locally\n{% codeblock %}hexo server or hexo s{% endcodeblock %}\n* my favourite - website deploy\n{% codeblock %}hexo deploy{% endcodeblock %}\n\nNow you should be ready to start your blog journey on GitHub just like me. Good luck!\n","tags":["Hexo","blog","setup"]}]